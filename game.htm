<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>é–‹ç‡ˆéŠæˆ²</title>
    <style>
        body { 
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex; flex-direction: column; align-items: center; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: white; margin: 0; padding: 20px;
            min-height: 100vh;
        }
        .grid { display: grid; grid-template-columns: repeat(5, 70px); gap: 12px; }
        .light { 
            width: 70px; height: 70px; border-radius: 50%; 
            border: 4px solid #444; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); touch-action: manipulation;
        }
        .light.on { 
            background: linear-gradient(45deg, #fff176, #ffeb3b, #fbc02d);
            box-shadow: 0 0 30px #ffeb3b, inset 0 0 20px rgba(255,235,59,0.5);
        }
        button { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
            color: white; border: none; padding: 15px 25px; 
            font-size: 16px; border-radius: 30px; margin: 10px; 
            cursor: pointer; font-weight: bold; touch-action: manipulation;
            transition: transform 0.2s;
        }
        button:active { transform: scale(0.95); }
        button:hover { transform: scale(1.05); }
        #status { margin-top: 20px; font-size: 18px; text-align: center; }
        .solving { opacity: 0.7; pointer-events: none; }
    </style>
</head>
<body>
    <h1>ğŸ’¡ é–‹ç‡ˆéŠæˆ² ğŸ’¡</h1>
    <div id="grid" class="grid"></div>
    <div>
        <button onclick="resetGame()">ğŸ”„ é‡ç½®</button>
        <button onclick="randomGame()">ğŸ² éš¨æ©Ÿ</button>
        <button id="solveBtn" onclick="solveGame()">ğŸ§  è§£ç­”</button>
    </div>
    <div id="status">é»æ“Šé–‹å§‹éŠæˆ²ï¼</div>

    <script>
        let lights = Array(5).fill().map(() => Array(5).fill(0));
        const grid = document.getElementById('grid');
        const status = document.getElementById('status');
        const solveBtn = document.getElementById('solveBtn');
        let solving = false;
        
        function createGrid() {
            grid.innerHTML = '';
            for(let i = 0; i < 5; i++) {
                for(let j = 0; j < 5; j++) {
                    const div = document.createElement('div');
                    div.className = 'light';
                    div.onclick = () => toggle(i, j);
                    grid.appendChild(div);
                }
            }
            updateGrid();
        }
        
        function toggle(x, y) {
            if(solving) return;
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[0,0]];
            dirs.forEach(([dx, dy]) => {
                const nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < 5 && ny >= 0 && ny < 5) {
                    lights[nx][ny] = 1 - lights[nx][ny];
                }
            });
            updateGrid();
            requestAnimationFrame(checkWin);
        }
        
        function updateGrid() {
            const cells = grid.children;
            for(let i = 0, idx = 0; i < 5; i++) {
                for(let j = 0; j < 5; j++, idx++) {
                    cells[idx].className = `light ${lights[i][j] ? 'on' : ''}`;
                }
            }
        }
        
        function checkWin() {
            if(lights.every(row => row.every(v => v))) {
                status.textContent = 'ğŸ‰ æ­å–œé€šé—œï¼';
            }
        }
        
        function resetGame() {
            lights = Array(5).fill().map(() => Array(5).fill(0));
            updateGrid();
            status.textContent = 'éŠæˆ²å·²é‡ç½®ï¼';
            solving = false;
            solveBtn.classList.remove('solving');
        }
        
        function randomGame() {
            lights = Array(5).fill().map(() => 
                Array(5).fill().map(() => Math.random() > 0.5 ? 1 : 0));
            updateGrid();
            status.textContent = 'ğŸ² æ–°æŒ‘æˆ°ï¼';
            solving = false;
            solveBtn.classList.remove('solving');
        }
        
        // iPhone Safari å„ªåŒ–ç‰ˆè§£ç­”å™¨
        async function solveGame() {
            if(solving) return;
            solving = true;
            solveBtn.classList.add('solving');
            status.textContent = 'ğŸ§  è¨ˆç®—è§£ç­”ä¸­...';
            
            // å¿«é€Ÿå»ºç«‹çŸ©é™£ (éåŒæ­¥)
            const N = 25;
            const A = Array(N).fill().map(() => Array(N).fill(0));
            const b = Array(N).fill(1);
            
            // å¡«å…¥å½±éŸ¿çŸ©é™£
            for(let i = 0; i < 5; i++) {
                for(let j = 0; j < 5; j++) {
                    let idx = i * 5 + j;
                    A[idx][idx] = 1;
                    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                    for(let [dx, dy] of dirs) {
                        let ni = i + dx, nj = j + dy;
                        if(ni >= 0 && ni < 5 && nj >= 0 && nj < 5) {
                            let nidx = ni * 5 + nj;
                            A[idx][nidx] = 1;
                        }
                    }
                }
            }
            
            // ç•¶å‰ç‹€æ…‹
            for(let i = 0; i < 5; i++) {
                for(let j = 0; j < 5; j++) {
                    let idx = i * 5 + j;
                    b[idx] = (b[idx] + lights[i][j]) % 2;
                }
            }
            
            // é«˜æ–¯æ¶ˆå…ƒ (åˆ†æ­¥åŸ·è¡Œé¿å…é˜»å¡)
            await solveGaussian(A, b);
            
            // æ‰¾å‡ºè§£ç­”
            let solution = [];
            for(let i = 0; i < 5; i++) {
                for(let j = 0; j < 5; j++) {
                    let idx = i * 5 + j;
                    if(b[idx]) solution.push([i, j]);
                }
            }
            
            // ä½¿ç”¨ requestAnimationFrame å‹•æ…‹æ¼”ç¤º (iPhone æœ€ä½³åŒ–)
            let step = 0;
            function executeStep() {
                if(step < solution.length) {
                    let [x, y] = solution[step];
                    toggle(x, y);
                    step++;
                    requestAnimationFrame(executeStep);
                } else {
                    status.textContent = 'ğŸ§  æ•¸å­¸è‡ªå‹•è§£ç­”å®Œæˆï¼';
                    solving = false;
                    solveBtn.classList.remove('solving');
                    requestAnimationFrame(checkWin);
                }
            }
            requestAnimationFrame(executeStep);
        }
        
        // éåŒæ­¥é«˜æ–¯æ¶ˆå…ƒ (é¿å… Safari åŸ·è¡Œç·’é™åˆ¶)
        async function solveGaussian(A, b) {
            const N = A.length;
            
            // å‰å‘æ¶ˆå…ƒ
            for(let p = 0; p < N; p++) {
                // æ‰¾æ¨ç´
                let max = p;
                for(let i = p + 1; i < N; i++) {
                    if(A[i][p] > A[max][p]) max = i;
                }
                // äº¤æ›
                [A[p], A[max]] = [A[max], A[p]];
                [b[p], b[max]] = [b[max], b[p]];
                
                // æ¶ˆå…ƒ
                for(let i = p + 1; i < N; i++) {
                    if(A[i][p]) {
                        for(let j = p; j < N; j++) {
                            A[i][j] = (A[i][j] + A[p][j]) % 2;
                        }
                        b[i] = (b[i] + b[p]) % 2;
                    }
                    // è®“å‡ºåŸ·è¡Œç·’
                    if(p % 5 === 0) await new Promise(r => requestAnimationFrame(r));
                }
            }
            
            // å›ä»£
            for(let i = N - 1; i >= 0; i--) {
                for(let k = N - 1; k > i; k--) {
                    b[i] = (b[i] + A[i][k] * b[k]) % 2;
                }
            }
        }
        
        createGrid();
    </script>
</body>
</html>
